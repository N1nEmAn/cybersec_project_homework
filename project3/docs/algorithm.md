# Poseidon2 算法详解

## 概述

Poseidon2 是 Poseidon 哈希函数的优化版本，专为零知识证明系统设计。本文档详细解释了 Poseidon2 的算法原理、数学基础和优化策略。

## 数学基础

### 有限域运算

Poseidon2 工作在有限域 𝔽_p 上，其中：

```
p = 21888242871839275222246405745257275088548364400416034343698204186575808495617
```

这是 BLS12-381 椭圆曲线的标量域大小。

### 状态表示

Poseidon2 维护一个状态向量 **s** ∈ 𝔽_p^t，其中 t 是状态大小：

- (256,3,5) 配置: t = 3
- (256,2,5) 配置: t = 2

状态初始化：
```
s₀ = [input₁, input₂, 0]  # 对于 t=3
s₀ = [input₁, input₂]     # 对于 t=2
```

## 核心算法结构

### 置换函数 π

Poseidon2 的核心是置换函数 π: 𝔽_p^t → 𝔽_p^t，定义为：

```
π(x) = π_R(π_{R-1}(...π_1(x)...))
```

其中每一轮 π_i 包含三个步骤：

1. **加轮常数** (AddRoundConstants)
2. **S-box 层** (SubBytes)  
3. **线性层** (MixColumns)

### 轮函数设计

#### 完整轮 (Full Round)

在完整轮中，S-box 应用于所有状态元素：

```
for i = 0 to t-1:
    s[i] ← s[i] + C[round][i]    // 加轮常数
    s[i] ← s[i]^5                // S-box
s ← M × s                        // 线性层
```

#### 部分轮 (Partial Round)

在部分轮中，S-box 仅应用于第一个状态元素：

```
for i = 0 to t-1:
    s[i] ← s[i] + C[round][i]    // 加轮常数
s[0] ← s[0]^5                    // S-box (仅第一个元素)
s ← M × s                        // 线性层
```

### 轮数配置

根据 Poseidon2 论文 Table 1：

| 配置 (n,t,d) | R_F | R_P | 总轮数 |
|--------------|-----|-----|---------|
| (256,3,5)    | 8   | 56  | 64      |
| (256,2,5)    | 8   | 57  | 65      |

其中：
- R_F: 完整轮数 (前 R_F/2 轮 + 后 R_F/2 轮)
- R_P: 部分轮数 (中间轮次)

## S-box 函数

### 数学定义

S-box 函数定义为：

```
S(x) = x^5 mod p
```

选择指数 5 的原因：
1. **代数度**: 提供足够的非线性度
2. **电路友好**: 减少乘法约束数量
3. **安全性**: 抵抗差分和线性攻击

### 电路实现优化

标准实现需要 4 次乘法：
```
x^5 = x × x × x × x × x
```

优化实现只需 2 次乘法：
```
x² = x × x
x⁴ = x² × x²  
x⁵ = x⁴ × x
```

### Circom 实现

```circom
template Sbox() {
    signal input in;
    signal output out;
    
    signal x2 <== in * in;    // x²
    signal x4 <== x2 * x2;    // x⁴
    out <== x4 * in;          // x⁵
}
```

## 线性层

### MDS 矩阵

线性层使用最大距离可分（MDS）矩阵进行变换：

对于 t=3：
```
M = [2  1  1]
    [1  2  1]
    [1  1  3]
```

对于 t=2：
```
M = [2  1]
    [1  2]
```

### MDS 矩阵性质

1. **最大距离可分**: 提供最佳的扩散特性
2. **Cauchy 矩阵**: M[i][j] = 1/(x_i + y_j)
3. **循环结构**: 便于硬件实现

### 优化实现

标准矩阵乘法需要 9 次乘法（对于 3×3），优化实现可以减少到 6 次：

```javascript
// 优化的 3×3 MDS 矩阵乘法
function optimizedLinearLayer(state) {
    const [x0, x1, x2] = state;
    const sum = x0 + x1 + x2;
    
    return [
        sum + x0,      // 2x0 + x1 + x2
        sum + x1,      // x0 + 2x1 + x2
        sum + x2 + x2  // x0 + x1 + 3x2
    ];
}
```

## 轮常数生成

### Grain LFSR

轮常数使用 Grain 线性反馈移位寄存器生成：

```
LFSR 多项式: f(x) = x⁸⁰ + x⁷⁸ + x⁷² + x⁶² + x⁵⁷ + x⁴⁰ + x³⁶ + x²⁴ + x²¹ + x¹³ + x⁹ + x¹ + 1
```

### 生成过程

1. 初始化 80 位 LFSR 状态
2. 为每个轮次和状态位置生成 254 位常数
3. 确保常数在有效字段范围内

### 安全性要求

- **非零性**: 所有常数非零
- **唯一性**: 所有常数互不相同  
- **随机性**: 通过统计测试
- **无结构**: 避免代数关系

## 安全性分析

### 抗攻击能力

#### 差分攻击

Poseidon2 通过以下机制抵抗差分攻击：

1. **S-box 非线性**: x^5 提供差分均匀性
2. **MDS 扩散**: 确保差分快速扩散
3. **轮数充足**: 超过安全边际的轮数

最小轮数计算：
```
R_min = 2 × log_d(t) + log_d(2^n) + 2
```

其中 d = 5 (S-box 指数)，n = 254 (字段大小)

#### 线性攻击

线性攻击抵抗通过以下方式实现：

1. **S-box 非线性**: 最小代数度
2. **轮常数**: 打破线性结构
3. **充足轮数**: 确保线性逼近概率足够低

#### 代数攻击

代数攻击防护：

1. **高代数度**: 经过足够轮数后达到最大代数度
2. **复杂多项式**: 避免低度多项式关系
3. **随机常数**: 防止结构化攻击

### 安全边际

目标安全级别：128 位

计算得出的安全边际：
- **差分**: > 150 位
- **线性**: > 140 位  
- **代数**: > 130 位

## 性能优化

### 轮数优化

Poseidon2 相比 Poseidon 的主要优化：

1. **部分轮策略**: 减少 S-box 操作
2. **优化 MDS**: 降低线性层复杂度
3. **常数优化**: 减少加法操作

### 约束数量对比

| 哈希函数 | 约束数 | 相对性能 |
|----------|--------|----------|
| SHA-256  | ~27000 | 1.0×     |
| Poseidon | ~1200  | 22.5×    |
| Poseidon2| ~800   | 33.7×    |

### 电路优化技术

#### S-box 优化
- 减少乘法约束从 4 个到 2 个
- 节约约束数量 50%

#### 线性层优化
- 利用矩阵特殊结构
- 减少乘法运算次数

#### 常数预计算
- 编译时生成所有轮常数
- 避免运行时计算开销

## 实现变体

### 不同状态大小

#### t=2 配置
- 输入: 2 个字段元素
- 输出: 1 个字段元素
- 轮数: 8 + 57 = 65
- 约束: ~650

#### t=3 配置  
- 输入: 2 个字段元素 + 1 个填充
- 输出: 1 个字段元素
- 轮数: 8 + 56 = 64
- 约束: ~800

### 特殊优化

#### 固定输入优化
对于已知输入模式，可以预计算部分状态转换。

#### 批处理优化
多个哈希计算可以并行化处理。

#### 内存优化
流式处理大量输入，减少内存占用。

## 电路约束分析

### 约束分布

```
总约束 = S-box约束 + 线性层约束 + 加法约束

S-box约束 = 轮数 × S-box数量 × 2
线性层约束 = 轮数 × t × (t-1)  
加法约束 = 轮数 × t
```

### 优化策略

1. **减少S-box数量**: 使用部分轮
2. **优化MDS矩阵**: 减少乘法运算
3. **常数合并**: 预计算轮常数

## 与其他哈希函数比较

### Poseidon vs Poseidon2

| 特性 | Poseidon | Poseidon2 |
|------|----------|-----------|
| 轮结构 | 全完整轮 | 完整轮+部分轮 |
| 约束数 | 更多 | 更少 |
| 安全性 | 高 | 相当 |
| 优化度 | 中等 | 高 |

### 传统哈希函数

| 函数 | 设计目标 | ZK友好度 |
|------|----------|----------|
| SHA-256 | 通用安全 | 低 |
| Blake2 | 高性能 | 中 |
| Poseidon | ZK优化 | 高 |
| Poseidon2 | ZK最优 | 极高 |

## 未来发展方向

### 算法改进

1. **新的S-box设计**: 探索其他指数
2. **矩阵优化**: 更高效的MDS矩阵
3. **轮数优化**: 动态轮数调整

### 应用扩展

1. **多输入支持**: 支持更多输入元素
2. **可变输出**: 不同长度的哈希输出
3. **流式处理**: 处理任意长度输入

### 硬件实现

1. **ASIC优化**: 专用芯片设计
2. **FPGA实现**: 可重配置硬件
3. **GPU加速**: 并行计算优化

## 参考文献

1. Grassi, L., et al. "Poseidon2: A Faster Version of the Poseidon Hash Function." IACR Cryptology ePrint Archive 2023/323 (2023).
2. Grassi, L., et al. "Poseidon: A New Hash Function for Zero-Knowledge Proof Systems." USENIX Security 2021.
3. Daemen, J., & Rijmen, V. "The Design of Rijndael: AES-The Advanced Encryption Standard." Springer Science & Business Media, 2013.
4. Albrecht, M., et al. "MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity." ASIACRYPT 2016.

---

*本文档提供了 Poseidon2 哈希算法的完整技术规范，为实现和优化提供理论基础。*
